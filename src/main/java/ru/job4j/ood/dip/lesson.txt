В этом уроке речь пойдет о принципе DIP (Dependency Inversion Principle) - принцип инверсии зависимостей.

Данный принцип гласит:

Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракций.

Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Проще говоря, используемые сущности в вашем коде должны быть абстракциями, т.е. не должно быть прямой зависимости от реализации.

Это касается:

- полей классов
- возвращаемых значений методов
- аргументов методов и конструкторов
- создаваемых объектов (вспомните пример из урока про SRP)

Чаще всего это не касается моделей данных бизнес-логики, т.е. классов типа Item, Post, User, Role и т.д, однако если

они также содержат какую-то логику, то правило также действует и на них.

Рассмотрим такой пример. Пусть нам нужно написать сервис простого интернет магазина:

У нас есть базовая сущность:

 
package ru.job4j.ood.dip;

import java.util.Objects;

public abstract class BaseEntity {

    protected int id;

    protected String name;

    public BaseEntity(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        BaseEntity that = (BaseEntity) o;
        return id == that.id && Objects.equals(name, that.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}
и такие модели:

package ru.job4j.ood.dip;

public class User extends BaseEntity {
    public User(int id, String name) {
        super(id, name);
    }
}

package ru.job4j.ood.dip;

public class Product extends BaseEntity {
    public Product(int id, String name) {
        super(id, name);
    }
}
 
package ru.job4j.ood.dip;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class Order {

    private int id;

    private boolean isPayed;

    private Map<Integer, Product> products = new HashMap<>();

    public boolean add(Product product) {
        if (products.containsKey(product.getId())) {
            return false;
        }
        return products.put(product.getId(), product) != null;
    }

    public boolean remove(int id) {
        return products.remove(id) != null;
    }

    public void clear() {
        products.clear();
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public boolean isPayed() {
        return isPayed;
    }

    public void setPayed(boolean payed) {
        isPayed = payed;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Order order = (Order) o;
        return id == order.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

package ru.job4j.ood.dip;

public class Check extends BaseEntity {
    public Check(int id, String name) {
        super(id, name);
    }
}

и есть сам класс сервис:

package ru.job4j.ood.dip;

import java.util.*;

public class SimpleShopService {

    private HashMap<User, Set<Order>> serviceDB = new HashMap<>();

    public boolean createBucket(User user) {
        if (serviceDB.containsKey(user)) {
            return false;
        }
        return serviceDB.put(user, new HashSet<>()) != null;
    }

    public boolean createOrder(User user, Order order) {
        Set<Order> orders = serviceDB.getOrDefault(user, Set.of());
        if (orders.isEmpty()) {
            return false;
        }
        return orders.add(order);
    }

    public boolean addProduct(User user, Order order, Product product) {
        Optional<Order> orderDB = findOrder(user, order);
        if (orderDB.isEmpty()) {
            return false;
        }
        return orderDB.get().add(product);
    }

    private Optional<Order> findOrder(User user, Order order) {
        return serviceDB.getOrDefault(user, Set.of()).stream()
                .filter(o -> o.getId() == order.getId())
                .findFirst();
    }

    public boolean removeProduct(User user, Order order, Product product) {
        Optional<Order> orderDB = findOrder(user, order);
        if (orderDB.isEmpty()) {
            return false;
        }
        return orderDB.get().remove(product.getId());
    }

    public boolean removeOrder(User user, Order order) {
        Set<Order> orders = serviceDB.get(user);
        if (orders == null) {
            return false;
        }
        return orders.remove(order);
    }

    public Check payOrder(User user, Order order) {
        Optional<Order> orderDB = findOrder(user, order);
        if (orderDB.isEmpty()) {
            System.out.println("Get error with " + user + " " + order);
            throw new IllegalArgumentException("Invalid order");
        }
        if (orderDB.get().isPayed()) {
            System.out.println("Get error with "  + user + " " + order);
            throw new IllegalArgumentException("Already payed!");
        }
        orderDB.get().setPayed(true);
        return new Check((int) (System.currentTimeMillis() % 1000_000), "Payed: " + orderDB.get().getId());
    }

}
 

На что стоит обратить внимание? 

1. Поля. У сервиса есть единственное поле - мапа, для хранения данных. С точки зрения DIP, это нарушение, потому что мы зависим от реализации, а не абстракции. Решение - выделение абстракции для хранилища и уже далее от него нужно будет реализовать InMemoryShopStore

package ru.job4j.ood.dip;

import java.util.Set;

public interface ShopStore {

    boolean saveUser(User user);
    boolean saveOrder(User user, Order order);
    Set<Order> getOrders(User user);
    Set<User> getUsers();
    
}
и в самом сервисе избавиться от зависимости на само хранилище. Тогда можно будет его подменить на любое другое, т.к. нет прямой зависимости.

private ShopStore shopStore;

public SimpleShopService(ShopStore shopStore) {
    this.shopStore = shopStore;
}
2. Стоит обратить внимание на подобные строки. Вы уже знакомы с логгированием, которое проходили в разделе IO. Подобная запись также является нарушением DIP, потому что есть прямая зависимость самого логгирования от реализации, в данном случае оно напрямую зависит от консольного вывода.

System.out.println("Get error with "  + user + " " + order);
Решение опять использование абстракции для логирования

private static final Logger LOGGER = Logger.getLogger("Shop logger");
3. На входные параметры. В данном случае на Order. Во-первых, этот класс нарушает SPR, потому что представляет как саму модель заказа так и АПИ для работы с ней. Во-вторых, он нарушает DIP, потому что опять же сохранения идет в память, нам нужно здесь аналогично абстрагироваться от самого хранилища, создав для него отдельный интерфейс. Но зависимость от хранилища уже будет в сервис заказа, а сервис магазина будет зависеть от сервиса заказов

package ru.job4j.ood.dip;

public class SimpleOrderService implements OrderService {

    private OrderStore orderStore;

    public SimpleOrderStore(OrderStore orderStore) {
        this.orderStore = orderStore;
    }
}

// уже в классе ShopService
private OrderService orderService;

public SimpleShopService(ShopStore shopStore, OrderService orderService) {
    this.shopStore = shopStore;
    this.orderService = orderService;
}